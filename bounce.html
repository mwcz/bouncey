<!DOCTYPE html>

<html>

<head>

<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">

<title>~\workspace\bounce.html.html</title>
<meta name="Generator" content="Vim/7.3">
<meta name="plugin-version" content="vim7.3_v6">
<meta name="syntax" content="html">
<meta name="settings" content="use_css">

<style type="text/css">
<!--
    pre  { font-family: Terminus, monospace; color: #dcdccc; background-color: #1f1f1f; }
    body { font-family: Terminus, monospace; color: #dcdccc; background-color: #1f1f1f; }
    canvas { border: 1px solid grey; }
-->
</style>

<script type="text/javascript">
<!--

/****************************************************************
 * BounceObject                                                 *
 * this class is the parent class of all objects that get drawn *
 * on the canvas.                                               *
 * @param _x  the x coordinate                                  *
 * @param _y  the y coordinate                                  *
 * @param _vx the initial x velocity                            *
 * @param _vy the initial y velocity                            *
 ****************************************************************/
function BounceObject( _x, _y, _vx, _vy, _c ) {
    this.color = _c;
    this.x     = _x;
    this.y     = _y;
    this.vx    = _vx;
    this.vy    = _vy;
}

// The default draw function does nothing
BounceObject.prototype.draw    = function() { }

// Collide SHOULD accept any other BounceObject and
// determine if the instance collides with that
// object.  I have a few ideas of how to implement
// this, but none of them are clean.  Right now, I
// think I'll implement it as ONLY detecting collisions
// between BounceObjects of the same subclass,
// Circle hits Circle, for example, but no Circle
// hits Rectangle.
BounceObject.prototype.collide = function() { }

/*************************************************************
 * class Circle                                              *
 * a plain ol' circle                                        *
 * @param _r  the radius                                      *
 * @param _c  the color in rgb(R,G,B) or rgba(R,G,B,A) format *
 *************************************************************/

Circle.prototype = new BounceObject;
Circle.prototype.constructor = Circle;

Circle.prototype.draw = function( _canvas ) {
    _canvas.fillStyle = this.color;
    _canvas.beginPath();
    _canvas.arc( this.x, this.y, this.r, 0, PI2, true );
    _canvas.closePath();
    _canvas.fill();
};

Circle.prototype.collide = function( _obj ) {
    // TODO: resume here!
}

function Circle( _x, _y, _r, _vx, _vy, _c ) {

    // call the superclass's constructor and pass in the variables it cares about
    BounceObject.call( this, _x, _y, _vx, _vy, _c );

    // initialize this class's variables
    this.r = _r;

}


/*******************
 * Global settings *
 *******************/
var FPS    = 60;         // frames per second
var PERIOD = 1000 / FPS; // frames last PERIOD milliseconds
var W      = 500;        // canvas width
var H      = 375;        // canvas height
var OBJ_R  = 10;
var OBJ_W  = 10;
var OBJ_H  = 10;
var PI2    = Math.PI * 2;

/***********************
 * toggleable settings *
 ***********************/
var paused = false;

/********************************************************************
 * This is the most confusing part.  'objs' is an array of objects. *
 * They are stored in this format:                                  *
 * objs = [                                                         *
 *           ...,                                                   *
 *           [ x, y, vx, vy, w, h, [r,g,b] ],                       *
 *           ...,                                                   *
 *        ];                                                        *
 * Legend:                                                          *
 *     x : the object's x-axis position                             *
 *     y : the object's y-axis position                             *
 *     vx: the object's x-axis velocity                             *
 *     vy: the object's y-ayis velocity                             *
 *     w : the object's width                                       *
 *     h : the object's height                                      *
 *     r : the object's r-channel color value                       *
 *     g : the object's g-channel color value                       *
 *     b : the object's b-channel color value                       *
 ********************************************************************/
objs = [];

function make_frame() {     // stuff to do for each frame
    update();
    paint();
}

/***************************************************
 * update all the objects positions and velocities *
 ***************************************************/
function update() {

    if ( paused ) return; // this is kind of a hack

    var x_col  = false;
    var y_col  = false;
    var curobj = new Object();

    for ( var o = objs.length - 1; o >= 0; --o ) {
    
        curobj = objs[o];

        // x-axis collisions:
        x_col = curobj.x + curobj.r >= W    // right wall collision
             || curobj.x - curobj.r <= 0    // left wall collision
             ;

        // y-axis collisions:
        y_col = curobj.y + curobj.r >= H    // bottom wall collision
             || curobj.y - curobj.r <= 0    // top wall collision
             ;

        if( x_col ) curobj.vx *= -1;
        if( y_col ) curobj.vy *= -1;

        /* this is ugly */
        /*
        for ( var p = objs.length - 1; p >= 0; --p ) {

            if( o == p ) continue;

            if ( ( collision = collide( o, p ) ) ) {

                // after a collision, the velocity of each object changes only on
                // the axis on which the collision took place.
                // i.e. - zero friction
                if ( collision == 1 ) {
                    var dvx = objs[p].vx - curobj.vx; // delta v on the x-axis
                    curobj.vx += dvx;
                    objs[p].vx -= dvx;
                } else if ( collision == 2 ) {
                    var dvy = objs[p].vy - curobj.vy; // delta v on the y-ayis
                    curobj.vy += dvy;
                    objs[p].vy -= dvy;
                }
                break;
            }

        }
        */

        curobj.x = curobj.x + curobj.vx * 1/FPS;
        curobj.y = curobj.y + curobj.vy * 1/FPS;
    }
}

/********************************************
 * paint a frame by drawing all the objects *
 ********************************************/
function paint() {

    if ( paused ) return; // this is kind of a hack

    canvas.clearRect(0,0,W,H);

    for( var o = objs.length - 1; o >= 0; --o ) {

        objs[o].draw( canvas );

    }
}

/********************************************************
 * returns true if _o1 and _o2 overlap, false otherwise *
 ********************************************************/
function collide( _o1, _o2 ) {

    var x1     = Math.abs( Math.round( _o1.x ) );
    var y1     = Math.abs( Math.round( _o1.y ) );
    var r1     = _o1.r;

    var x2     = Math.abs( Math.round( _o2.x ) );
    var y2     = Math.abs( Math.round( _o2.y ) );
    var r2     = _o2.r;

    var x_hit  = false;
    var y_hit  = false;

    var x_dist = Math.abs( x2 - x1 );
    var y_dist = Math.abs( y2 - y1 );
    var dist   = Math.sqrt( x_dist^2 + y_dist^2 );

    // if the distance between _o1's center and _o2's center
    // is less than or equal to r1+r2, then they have collided

    return dist <= r1 + r2;

}


window.onload = function() {

    canvas_element        = document.getElementById('cnvs');
    canvas_element.width  = W;
    canvas_element.height = H;

    canvas = canvas_element.getContext('2d');

    // create some squares with random velocities in the center of the canvas
    // objects are stored in the format 
    //      [ X, Y, X_velocity, Y_velocity, width, height, [R,G,B] ]
    var x, y, w, h, v_x, v_y, r, g, b, new_obj;

    // calculate all the possible initial y positions
    y_positions = [];
    for( var i = H % (2*OBJ_R+10) - 1; i >= 0; --i )
        y_positions.push( (i+1) * (2*OBJ_R+10)/2 );

    // calculate all the possible initial x positions
    x_positions = [];
    for( var i = W % (2*OBJ_R+10) - 1; i >= 0; --i )
        x_positions.push( (i+1) * (2*OBJ_R+10)/2 );

    /*
    */
    for( var i = 0; i < 75; ++i ) {

        // create values for the object
        x   = x_positions[ i % x_positions.length ];
        y   = y_positions[ i % y_positions.length ];
        v_x = Math.random() * 200;
        v_y = Math.random() * 200;
        r   = Math.floor( Math.random() * 200 + 55 ); // random value 55..255
        g   = Math.floor( Math.random() * 200 + 55 );
        b   = Math.floor( Math.random() * 200 + 55 );

        // add the object to the scene
        var color = 'rgb(' + r + ',' + g + ',' + b + ')';
        var new_obj = new Circle( x, y, OBJ_R, v_x, v_y, color );

        objs.push( new_obj );
    }

  // Test Cases:
  //objs.push( [ 20          ,  20,  60,   0, OBJ_W, OBJ_H, [255, 0  , 0] ] );
  //objs.push( [ W-(20+OBJ_W),  20, -60,   0, OBJ_W, OBJ_H, [0  , 255, 0] ] );
  //objs.push( [ 20          ,  60, 120,   0, OBJ_W, OBJ_H, [0  , 0  , 255] ] );
  //objs.push( [ W/2         ,  60,  30,   0, OBJ_W, OBJ_H, [255, 255, 0] ] );
  //objs.push( [ 20          , 100,  60,   0, OBJ_W, OBJ_H, [255, 0  , 255] ] );
  //objs.push( [ W-(20+OBJ_W), 100, -30,   0, OBJ_W, OBJ_H, [0  , 255, 255] ] );
    /* These two cause the objects to bind together inappropriately */
  //objs.push( [ 20          ,  20,  20,  10, OBJ_W, OBJ_H, [255, 0  , 255] ] );
  //objs.push( [ 80          ,  39, -80,  10, OBJ_W, OBJ_H, [0  , 255, 255] ] );

    setInterval( make_frame, PERIOD );

    /* can this work?
    setInterval( update, 1 );
    setInterval( make_frame, PERIOD );
    */

}





-->
</script>

</head>
<body>
<pre>
bounce demo

<canvas id="cnvs" width="500" height="375">
</canvas>

</pre>



</body></html>
